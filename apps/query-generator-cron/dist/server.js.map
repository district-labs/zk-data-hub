{"version":3,"sources":["../src/cron-jobs/axiom-query/send-axiom-query.ts","../src/actions/axiom-query/send-axiom-query.ts","../src/constants.ts","../src/env.ts","../src/lib/axiom-v2/index.ts","../src/lib/axiom-v2/circuit/index.ts","../src/lib/axiom-v2/utils/index.ts","../src/lib/axiom-v2/circuit/circuit.ts","../src/server.ts"],"names":["defaultInputs","axiom"],"mappings":"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","sourcesContent":["import { CronJob } from \"cron\";\nimport \"dotenv/config\";\nimport { sendAxiomQuery } from \"../../actions/axiom-query/send-axiom-query\";\n\n/**\n * Cron job to Send Axiom queries every 30 minutes\n */\nexport const jobSendAxiomQuery = new CronJob(\n  \"0 */30 * * * *\", // cronTime\n  async function () {\n    console.log(\"Sending Axiom queries\");\n    await sendAxiomQuery();\n  }, // onTick\n  null, // onComplete\n  true, // start\n  \"America/Los_Angeles\", // timeZone\n);\n","import { createPublicClient, http } from \"viem\";\nimport { goerli } from \"viem/chains\";\nimport { UNI_V3_TEST_POOLS } from \"../../constants\";\nimport { env } from \"../../env\";\nimport { axiomMain } from \"../../lib/axiom-v2\";\n\nexport async function sendAxiomQuery() {\n  try {\n    const client = createPublicClient({\n      chain: goerli,\n      transport: http(env.GOERLI_PROVIDER_URL),\n    });\n\n    const blockNumber = await client.getBlockNumber();\n\n    for (let i = 0; i < UNI_V3_TEST_POOLS.length; i++) {\n      await axiomMain(\n        {\n          poolBlockNumber: Number(blockNumber),\n          poolAddress: UNI_V3_TEST_POOLS[i] as string,\n        },\n        env.CALLBACK_ADDRESS,\n      );\n    }\n  } catch (error) {\n    console.log(error);\n    return error;\n  }\n}\n","export const UNIV3_POOL_TEST_WETH_USDC =\n  \"0xDd4bc61c941CE0e14560c87403E24Fdb94864eFB\";\nexport const UNIV3_POOL_TEST_RIZZ_USDC =\n  \"0x33E205Fab2d5C9f542860073A190A6d8365A932e\";\nexport const UNIV3_POOL_TEST_DIS_USDC =\n  \"0xc8EE7720c11038a2Af75B40f4F7989B912584cCB\";\n\nexport const UNI_V3_TEST_POOLS = [\n  UNIV3_POOL_TEST_WETH_USDC,\n  UNIV3_POOL_TEST_RIZZ_USDC,\n  UNIV3_POOL_TEST_DIS_USDC,\n];\n","import { createEnv } from \"@t3-oss/env-core\";\nimport \"dotenv/config\";\nimport { isAddress } from \"viem\";\nimport { z } from \"zod\";\n\nexport const env = createEnv({\n  server: {\n    GOERLI_PROVIDER_URL: z.string().url(),\n    GOERLI_PRIVATE_KEY: z.string().min(64).max(66),\n    CALLBACK_ADDRESS: z.string().refine((value) => isAddress(value)),\n  },\n  runtimeEnv: {\n    GOERLI_PROVIDER_URL: process.env.GOERLI_PROVIDER_URL,\n    GOERLI_PRIVATE_KEY: process.env.GOERLI_PRIVATE_KEY,\n    CALLBACK_ADDRESS: process.env.CALLBACK_ADDRESS,\n  },\n  skipValidation: !!process.env.SKIP_ENV_VALIDATION,\n  emptyStringAsUndefined: true,\n});\n","// import { env } from \"@/env.mjs\";\nimport {\n  Axiom,\n  BuiltQueryV2,\n  QueryBuilderV2,\n  bytes32,\n} from \"@axiom-crypto/core\";\nimport { ethers } from \"ethers\";\nimport type { Address } from \"viem\";\nimport { env } from \"../../env\";\nimport { MyAxiomCircuit } from \"./circuit\";\nimport { myCircuitFn, type MyInputs } from \"./circuit/circuit\";\n\n// Axiom SDK\nconst axiom = new Axiom({\n  providerUri: env.GOERLI_PROVIDER_URL,\n  privateKey: env.GOERLI_PRIVATE_KEY,\n  version: \"v2\",\n  chainId: 5, // Goerli\n  mock: true, // generate Mock proofs for faster development\n});\n\nconst defaultInputs: MyInputs = {\n  poolBlockNumber: 10076470,\n  poolAddress: \"0x5c33044BdBbE55dAb3d526CE70F908aAF6990373\",\n};\n\nasync function generateQuery(\n  loadedCircuit: MyAxiomCircuit,\n  poolBlockNumber: number,\n  poolAddress: string,\n  callbackAddr: string,\n): Promise<{\n  query: QueryBuilderV2;\n  builtQuery: BuiltQueryV2;\n  payment: string;\n}> {\n  const callback = {\n    target: callbackAddr,\n    extraData: bytes32(0),\n  };\n  const input: MyInputs = {\n    poolBlockNumber,\n    poolAddress,\n  };\n  await loadedCircuit.run(input);\n  return loadedCircuit.generateQuery(axiom, callback);\n}\n\nexport const axiomMain = async (\n  { poolAddress, poolBlockNumber }: MyInputs,\n  callbackAddr: Address,\n) => {\n  const customCircuit = new MyAxiomCircuit(\n    env.GOERLI_PROVIDER_URL,\n    myCircuitFn,\n  );\n  await customCircuit.setup();\n\n  // This only needs to be done once to lock the structure of your circuit.\n  await customCircuit.build(defaultInputs);\n  const querySchema = customCircuit.getQuerySchema();\n  console.log(\"Query schema: \", querySchema);\n\n  const { query, builtQuery, payment } = await generateQuery(\n    customCircuit,\n    poolBlockNumber,\n    poolAddress,\n    callbackAddr,\n  );\n  console.log(\"Query built with the following params:\", builtQuery);\n\n  console.log(\n    \"Sending a Query to AxiomV2QueryMock with payment amount (wei):\",\n    payment,\n  );\n\n  const queryId = await query.sendOnchainQuery(\n    payment,\n    (receipt: ethers.ContractTransactionReceipt) => {\n      // You can do something here once you've received the receipt\n      console.log(\"receipt\", receipt);\n    },\n  );\n\n  console.log(\n    \"View your Query on Axiom Explorer:\",\n    `https://explorer.axiom.xyz/v2/goerli/mock/query/${queryId}`,\n  );\n\n  return queryId;\n};\n","// @ts-nocheck\n\nimport {\n  Axiom,\n  AxiomV2Callback,\n  AxiomV2ComputeQuery,\n  AxiomV2DataQuery,\n  BuiltQueryV2,\n  DataSubquery,\n  QueryBuilderV2,\n  QueryV2,\n} from \"@axiom-crypto/core\";\nimport {\n  AxiomCircuitRunner,\n  DEFAULT_CIRCUIT_CONFIG,\n  autoConfigCircuit,\n} from \"@axiom-crypto/core/halo2-js\";\nimport {\n  CircuitConfig,\n  CircuitScaffold,\n  Halo2LibWasm,\n  getHalo2LibWasm,\n  getHalo2Wasm,\n} from \"@axiom-crypto/core/halo2-js/js\";\nimport { ethers, keccak256, solidityPacked } from \"ethers\";\nimport { convertToBytes, convertToBytes32 } from \"../utils\";\nimport { MyCircuitCode, MyInputs } from \"./circuit\";\n\nexport class MyAxiomCircuit extends CircuitScaffold {\n  private provider: ethers.JsonRpcProvider;\n  private halo2Lib!: Halo2LibWasm;\n  private myCircuitCode: MyCircuitCode;\n\n  private vkey?: Uint8Array;\n  private pkey?: Uint8Array;\n  private resultLen?: number;\n  private subqueries?: DataSubquery[];\n\n  /// Construct your circuit by providing a JSON-RPC provider URL along with your circuit code.\n  constructor(provider: string, myCircuitCode: MyCircuitCode) {\n    super({ shouldTime: false });\n    this.provider = new ethers.JsonRpcProvider(provider);\n    this.config = DEFAULT_CIRCUIT_CONFIG;\n    this.config.numVirtualInstance = 2;\n    this.myCircuitCode = myCircuitCode;\n  }\n\n  /// Constructors cannot be async, so the rest of the setup is here.\n  async setup() {\n    this.halo2wasm = await getHalo2Wasm(0);\n    super.newCircuitFromConfig(this.config);\n    if (this.halo2Lib) this.halo2Lib.free();\n    this.halo2Lib = getHalo2LibWasm(this.halo2wasm);\n  }\n\n  /// Finds optimal configuration for your circuit to give best proving times.\n  // eslint-disable-next-line\n  async tune() {\n    autoConfigCircuit(this.halo2wasm, this.config);\n  }\n\n  loadPrebuilt(config: CircuitConfig, pkey: Uint8Array, vkey: Uint8Array) {\n    this.config = config;\n    this.pkey = pkey;\n    this.vkey = vkey;\n    // eslint-disable-next-line\n    super.loadParams();\n    this.halo2wasm.loadPk(pkey);\n    this.halo2wasm.loadVk(vkey);\n  }\n\n  /// The circuit needs a default input to be able to run once and precompute\n  /// some information (this is called the proving key).\n  async build(defaultInputs: MyInputs) {\n    const { results } = await AxiomCircuitRunner(\n      this.halo2wasm,\n      this.halo2Lib,\n      this.config,\n      this.provider,\n    ).build(this.myCircuitCode, defaultInputs as any);\n    // eslint-disable-next-line\n    this.tune();\n    // configuration may have changed after tuning, so rebuild\n    this.newCircuitFromConfig(this.config);\n    const { numUserInstances } = await AxiomCircuitRunner(\n      this.halo2wasm,\n      this.halo2Lib,\n      this.config,\n      this.provider,\n    ).run(this.myCircuitCode, defaultInputs as any, results);\n    await this.keygen();\n\n    this.resultLen = numUserInstances / 2;\n    this.vkey = this.halo2wasm.getVk();\n    this.pkey = this.halo2wasm.getPk();\n  }\n\n  async run(inputs: MyInputs) {\n    const runner = AxiomCircuitRunner(\n      this.halo2wasm,\n      this.halo2Lib,\n      this.config,\n      this.provider,\n    );\n    // Runs my code once and uses SDK to get JSON-RPC data to populate the circuit\n    const { orderedDataQuery, results } = await runner.build(\n      this.myCircuitCode,\n      inputs as any,\n    );\n    const { numUserInstances } = await runner.run(\n      this.myCircuitCode,\n      inputs as any,\n      results,\n    );\n\n    this.prove();\n\n    this.resultLen = numUserInstances / 2;\n    this.subqueries = orderedDataQuery;\n  }\n\n  getProvingKey(): Uint8Array {\n    if (!this.pkey) throw new Error(\"You need to build your circuit first!\");\n    return this.pkey;\n  }\n\n  getVerifyingKey(): Uint8Array {\n    if (!this.vkey) throw new Error(\"You need to build your circuit first!\");\n    return this.vkey;\n  }\n\n  private getPartialVkey(): string[] {\n    if (!this.vkey) throw new Error(\"You need to build your circuit first!\");\n    const vkey = this.halo2wasm.getPartialVk();\n    return convertToBytes32(vkey);\n  }\n\n  getQuerySchema(): string {\n    if (!this.vkey) throw new Error(\"You need to build your circuit first!\");\n    const partialVk = this.halo2wasm.getPartialVk();\n    const vk = convertToBytes32(partialVk);\n    const packed = solidityPacked(\n      [\"uint8\", \"uint16\", \"uint8\", \"bytes32[]\"],\n      [this.config.k, this.resultLen, vk.length, vk],\n    );\n    return keccak256(packed);\n  }\n\n  private getComputeProof() {\n    if (!this.proof || !this.resultLen) throw new Error(\"No proof generated\");\n    let proofString = \"\";\n    const instances = this.getInstances();\n    for (let i = 0; i < this.resultLen; i++) {\n      const instanceHi = BigInt(instances[2 * i]);\n      const instanceLo = BigInt(instances[2 * i + 1]);\n      const instance = instanceHi * BigInt(2 ** 128) + instanceLo;\n      const instanceString = instance.toString(16).padStart(64, \"0\");\n      proofString += instanceString;\n    }\n    proofString += convertToBytes(this.proof);\n    return \"0x\" + proofString;\n  }\n\n  getComputeQuery(): AxiomV2ComputeQuery {\n    const vkey = this.getPartialVkey();\n    const computeProof = this.getComputeProof();\n    return {\n      k: this.config.k,\n      resultLen: this.resultLen as number,\n      vkey,\n      computeProof,\n    };\n  }\n\n  async getDataQuery(): Promise<AxiomV2DataQuery> {\n    if (!this.subqueries) {\n      throw new Error(\"You must run your circuit first!\");\n    }\n    const network = await this.provider.getNetwork();\n    const sourceChainId = network.chainId.toString();\n    return {\n      sourceChainId,\n      subqueries: this.subqueries,\n    };\n  }\n\n  async generateQuery(\n    axiom: Axiom,\n    callback: AxiomV2Callback,\n  ): Promise<{\n    query: QueryBuilderV2;\n    builtQuery: BuiltQueryV2;\n    payment: string;\n  }> {\n    const dataQuery = await this.getDataQuery();\n    const computeQuery = this.getComputeQuery();\n    const query = (axiom.query as QueryV2).new();\n    query.setBuiltDataQuery(dataQuery);\n    query.setComputeQuery(computeQuery);\n    query.setCallback(callback);\n\n    const built = await query.build();\n    // Calculates the fee (in wei) required to send the query\n    const payment = await query.calculateFee();\n\n    return {\n      query,\n      builtQuery: built,\n      payment,\n    };\n  }\n}\n","export const convertHexToUint8Array = (hexString: string): Uint8Array => {\n  if (hexString.slice(0, 2) === \"0x\") {\n    hexString = hexString.slice(2);\n  }\n  return new Uint8Array(Buffer.from(hexString, \"hex\"));\n};\n\nexport const convertToBytes32 = (inputArray: Uint8Array): string[] => {\n  const result: string[] = [];\n  for (let i = 0; i < inputArray.length; i += 32) {\n    const slice = inputArray.slice(i, i + 32);\n    const hex = \"0x\" + Buffer.from(slice).toString(\"hex\").padStart(64, \"0\");\n    result.push(hex);\n  }\n  return result;\n};\n\nexport const convertToBytes = (inputArray: Uint8Array): string => {\n  const hex = Buffer.from(inputArray).toString(\"hex\");\n  return hex;\n};\n","import { AxiomData } from \"@axiom-crypto/core/halo2-js\";\n\n/// These should be the _variable_ inputs to your circuit. Constants can be hard-coded into the circuit itself (see below).\n/// They will be auto-parsed into `MyCircuitInputs` type.\nexport interface MyInputs {\n  poolAddress: string;\n  poolBlockNumber: number;\n}\n\n/// These should be the _variable_ inputs to your circuit. Constants can be hard-coded into the circuit itself (see below).\nexport interface MyCircuitInputs {\n  poolBlockNumber: any;\n  poolAddress: any;\n}\n\nexport type MyCircuitCode = (\n  halo2Lib: any,\n  axiomData: AxiomData,\n  myInputs: MyCircuitInputs,\n) => Promise<void>;\n\nexport const myCircuitFn: MyCircuitCode = async (\n  halo2Lib: any,\n  axiomData: AxiomData,\n  myInputs: MyCircuitInputs,\n  // eslint-disable-next-line\n) => {\n  // ==== Imports to make circuit code work. DO NOT REMOVE. ====\n  // These are a list of available standard functions. Once you're finished with your circuit, you can remove the ones the linter says you don't use.\n  const { constant } = halo2Lib;\n  // These are a list of available functions for getting Ethereum data. Once you're finished with your circuit, you can remove the ones the linter says you don't use.\n  const { getStorage, addToCallback } = axiomData;\n  // ==== End of imports ====\n\n  // Below is the actual circuit code.\n  // Currently doc-hints are not supported in the IDE (coming soon!); for dochints you can write this code in repl.axiom.xyz first and then paste it here.\n  // For more detailed docs and a list of all data and compute functions, see our docs at:\n  //\n  // docs.axiom.xyz/axiom-repl/axiom-repl\n  //\n  const { poolBlockNumber, poolAddress } = myInputs;\n\n  // Uniswap V3 Pool Slot0 slot\n  const slot0Slot = constant(0);\n\n  // Uniswap V3 Pool Observations slot\n  const observationsSlot = constant(8);\n\n  // fetch storage data\n  const storage = getStorage(poolBlockNumber, poolAddress);\n\n  // access the value at storage slot `observationsSlot`\n  const observationsSlotValue = storage.slot(observationsSlot);\n  const slot0SlotValue = storage.slot(slot0Slot);\n\n  addToCallback(poolAddress);\n  addToCallback(poolBlockNumber);\n  addToCallback(observationsSlotValue);\n  addToCallback(observationsSlot);\n  addToCallback(slot0SlotValue);\n  addToCallback(slot0Slot);\n};\n","import { jobSendAxiomQuery } from \"./cron-jobs/axiom-query/send-axiom-query\";\n\njobSendAxiomQuery.start();\n"]}